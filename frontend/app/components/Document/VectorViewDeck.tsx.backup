'use client';

import type React from 'react';
import {useCallback, useEffect, useMemo, useState} from 'react';
import DeckGL from '@deck.gl/react';
import {PointCloudLayer} from '@deck.gl/layers';
import {OrbitView} from '@deck.gl/core';
import {GoTriangleDown} from 'react-icons/go';
import {MdCancel} from 'react-icons/md';

import {fetch_chunk, fetch_vectors} from '@/app/api';
import type {
  ChunkPayload,
  ChunkScore,
  Credentials,
  VectorGroup,
  VectorsPayload,
  VerbaChunk,
} from '@/app/types';
import {vectorToRGB} from './util';

// Fallback static palette for groups (RGB)
const GROUP_PALETTE: [number, number, number][] = [
  [0, 128, 0], // green
  [0, 0, 255], // blue
  [255, 0, 0], // red
  [255, 255, 0], // yellow
  [128, 0, 128], // purple
  [0, 255, 255], // cyan
  [255, 165, 0], // orange
  [50, 205, 50], // limegreen
  [255, 192, 203], // pink
  [0, 128, 128], // teal
  [148, 0, 211], // violet
  [34, 139, 34], // forestgreen
  [255, 215, 0], // gold
  [0, 0, 128], // navy
  [255, 0, 255], // magenta
  [123, 104, 238], // mediumslateblue
];

function getGroupColor(index: number): [number, number, number] {
  return GROUP_PALETTE[index % GROUP_PALETTE.length] ?? [0, 0, 0];
}

type VectorViewProps = {
  credentials: Credentials;
  selectedDocument: string | null;
  chunkScores?: ChunkScore[];
  production: 'Local' | 'Demo' | 'Production';
};

type PointDatum = {
  uuid: string;
  chunk_id: string;
  documentTitle: string;
  vector: { x: number; y: number; z: number };
  groupIndex: number;
};

const VectorViewDeck: React.FC<VectorViewProps> = ({
  credentials,
  selectedDocument,
  production,
  chunkScores,
}) => {
  const [isFetching, setIsFetching] = useState(false);
  const [vectors, setVectors] = useState<VectorGroup[]>([]);
  const [embedder, setEmbedder] = useState('');
  const [showAll, setShowAll] = useState(false);
  const [dynamicColor, setDymanicColor] = useState(true);
  const [hoverTitleState, setHoverTitleState] = useState<string | null>(null);
  const [viewMultiplication, setViewMultiplication] = useState(200);
  const [currentDimensions, setCurrentDimensions] = useState(0);

  const [selectedChunk, setSelectedChunk] = useState<null | string>(null);
  const [chunk, setChunk] = useState<VerbaChunk | null>(null);

  const [minX, setMinX] = useState(-1);
  const [maxX, setMaxX] = useState(1);
  const [minY, setMinY] = useState(-1);
  const [maxY, setMaxY] = useState(1);
  const [minZ, setMinZ] = useState(-1);
  const [maxZ, setMaxZ] = useState(1);

  const calculateMinMax = useCallback((values: number[]): { min: number; max: number } => {
    const min = Math.min(...values);
    const max = Math.max(...values);
    return { min, max };
  }, []);

  const getVectorCount = () => {
    let vector_count = 0;
    for (const vector_group of vectors) {
      vector_count += vector_group.chunks.length;
    }
    return vector_count;
  };

  const fetchChunk = useCallback(async () => {
    if (!selectedChunk) return;

    try {
      const data: ChunkPayload | null = await fetch_chunk(
        selectedChunk,
        embedder,
        credentials
      );

      if (data) {
        if (data.error !== '') {
          setChunk(null);
        } else {
          setChunk(data.chunk);
        }
      }
    } catch (_error) {
      setIsFetching(false);
    }
  }, [selectedChunk, embedder, credentials]);

  const fetchVectors = useCallback(async () => {
    try {
      setIsFetching(true);

      const data: VectorsPayload | null = await fetch_vectors(
        selectedDocument,
        showAll,
        credentials
      );

      if (data) {
        if (data.error !== '') {
          setIsFetching(false);
          setVectors([]);
          setCurrentDimensions(0);
          setEmbedder('None');
        } else {
          setVectors(data.vector_groups.groups);
          setEmbedder(data.vector_groups.embedder);
          setCurrentDimensions(data.vector_groups.dimensions);
          setIsFetching(false);

          if (!showAll && data.vector_groups.groups.length > 0) {
            const firstGroup = data.vector_groups.groups[0];
            if (firstGroup?.chunks && firstGroup.chunks.length > 0) {
              const xValues = firstGroup.chunks.map((v) => v.vector.x);
              const yValues = firstGroup.chunks.map((v) => v.vector.y);
              const zValues = firstGroup.chunks.map((v) => v.vector.z);

              const { min: _minX, max: _maxX } = calculateMinMax(xValues);
              setMinX(_minX);
              setMaxX(_maxX);

              const { min: _minY, max: _maxY } = calculateMinMax(yValues);
              setMinY(_minY);
              setMaxY(_maxY);

              const { min: _minZ, max: _maxZ } = calculateMinMax(zValues);
              setMinZ(_minZ);
              setMaxZ(_maxZ);
            }
          }
        }
      }
    } catch (_error) {
      setIsFetching(false);
    }
  }, [selectedDocument, showAll, credentials, calculateMinMax]);

  useEffect(() => {
    if (selectedDocument) {
      fetchVectors();
    } else {
      setVectors([]);
    }
  }, [selectedDocument, fetchVectors]);

  useEffect(() => {
    if (selectedChunk) {
      fetchChunk();
    } else {
      setChunk(null);
    }
  }, [selectedChunk, fetchChunk]);

  const allData: PointDatum[] = useMemo(() => {
    const out: PointDatum[] = [];
    vectors.forEach((vg, gi) => {
      vg.chunks.forEach((c) => {
        out.push({
          uuid: c.uuid,
          chunk_id: c.chunk_id,
          documentTitle: vg.name,
          vector: c.vector,
          groupIndex: gi,
        });
      });
    });
    return out;
  }, [vectors]);

  const highlightedUUIDs = useMemo(() => new Set((chunkScores ?? []).map(s => s.uuid)), [chunkScores]);

  const layers = useMemo(() => {
    return [
      new PointCloudLayer<PointDatum>({
        id: 'pc-layer',
        data: allData,
        pickable: true,
        pointSize: 3,
        parameters: {
          depthTest: true,
        },
        getPosition: (d: PointDatum) => [
          d.vector.x * viewMultiplication,
          d.vector.y * viewMultiplication,
          d.vector.z * viewMultiplication,
        ],
        getColor: (d: PointDatum) => {
          if (highlightedUUIDs.has(d.uuid)) {
            return [255, 255, 0, 255]; // yellow
          }
          if (selectedChunk === d.uuid) {
            return [0, 255, 0, 255]; // green
          }
          if (dynamicColor) {
            const [r, g, b] = vectorToRGB(
              d.vector,
              minX,
              maxX,
              minY,
              maxY,
              minZ,
              maxZ
            );
            return [r, g, b, 180];
          }
          const [r, g, b] = getGroupColor(d.groupIndex);
          return [r, g, b, 180];
        },
        onHover: ({object}: {object: PointDatum | null}) => {
          if (object) {
            setHoverTitleState(`${object.documentTitle} | ${object.chunk_id}`);
          } else {
            setHoverTitleState(null);
          }
        },
        onClick: ({object}: {object: PointDatum | null}) => {
          if (object) setSelectedChunk(object.uuid);
        },
      }),
    ];
  }, [allData, viewMultiplication, highlightedUUIDs, selectedChunk, dynamicColor, minX, maxX, minY, maxY, minZ, maxZ]);

  return (
    <div className="flex h-full w-full flex-col gap-2">
      <div className="flex w-full items-center justify-end gap-2">
        <div className="flex w-full items-start justify-between">
          {/* Left */}
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              {isFetching && (
                <div className="flex h-full items-center justify-center gap-2 text-text-alt-verba">
                  <span className="loading loading-spinner loading-xs lg:loading-sm" />
                </div>
              )}
              <p className="font-bold text-text-alt-verba text-xs lg:text-sm">
                Embedding Model:
              </p>
              <p className="text-text-alt-verba text-xs lg:text-sm">
                {embedder}
              </p>
            </div>
            <div className="flex items-center gap-1">
              <p className="font-bold text-text-alt-verba text-xs lg:text-sm">
                Hover:
              </p>
              <p
                className="max-w-[100px] truncate text-text-alt-verba text-xs lg:max-w-[300px] lg:text-sm"
                title={hoverTitleState ?? ''}
              >
                {hoverTitleState ?? ''}
              </p>
            </div>
            <div className="flex items-center gap-1">
              <p className="font-bold text-text-alt-verba text-xs lg:text-sm">
                Vectors:
              </p>
              <p className="text-text-alt-verba text-xs lg:text-sm">
                {vectors.length} x {getVectorCount()} x {currentDimensions}
              </p>
            </div>
          </div>

          <div className="flex min-w-[20vw] items-center justify-between gap-10">
            <div className="flex w-full flex-col gap-2">
              {production !== 'Demo' && (
                <div className="flex items-center justify-between gap-2">
                  <p className="text-text-alt-verba text-xs">
                    Show All Documents
                  </p>
                  <input
                    checked={showAll}
                    className="toggle"
                    onChange={(e) => {
                      setShowAll(e.target.checked);
                    }}
                    type="checkbox"
                  />
                </div>
              )}

              <div className="flex items-center justify-between gap-2">
                <p className="text-text-alt-verba text-xs">Dynamic Coloring</p>
                <input
                  checked={dynamicColor}
                  className="toggle"
                  onChange={(e) => {
                    setDymanicColor(e.target.checked);
                  }}
                  type="checkbox"
                />
              </div>
            </div>

            <div className="flex w-full flex-col gap-2">
              {/* Dropdown */}
              <div className="dropdown dropdown-bottom flex w-full items-center justify-start">
                <button
                  className="btn btn-sm flex w-full justify-start border-none bg-button-verba text-text-verba hover:bg-button-hover-verba"
                  disabled={true}
                  tabIndex={0}
                >
                  <GoTriangleDown size={15} />
                  <p>PCA</p>
                </button>
                <ul className="dropdown-content menu z-1 w-full rounded-box bg-base-100 p-2 shadow" />
              </div>
              {/* Zoom */}
              <div className="flex w-full items-center gap-2">
                <p className="text-sm text-text-alt-verba">Zoom</p>
                <input
                  className="range range-xs w-full grow"
                  max="1000"
                  min={0}
                  onChange={(e) => {
                    setViewMultiplication(Number(e.target.value));
                  }}
                  type="range"
                  value={viewMultiplication}
                />
              </div>
            </div>

            {chunk && (
              <button
                type="button"
                className="btn btn-square flex gap-2 border-none bg-button-verba text-text-verba hover:bg-warning-verba"
                onClick={() => {
                  setChunk(null);
                  setSelectedChunk(null);
                }}
              >
                <MdCancel size={15} />
              </button>
            )}
          </div>
        </div>
      </div>

      <div className="flex h-[45vh] w-full gap-5">
        <div
          className={`flex grow transition-all duration-300 ease-in-out ${
            selectedChunk ? 'w-2/3' : 'w-full'
          } h-full`}
        >
          <DeckGL
            views={[new OrbitView()]}
            controller={true}
            initialViewState={{
              target: [0, 0, 0],
              rotationX: 0,
              rotationOrbit: 0,
              zoom: 0.5,
            }}
            layers={layers}
            style={{width: '100%', height: '100%'}}
          />
        </div>
        <div
          className={`flex grow transition-all duration-300 ease-in-out ${
            selectedChunk ? 'w-1/3 opacity-100' : 'w-0 opacity-0'
          } overflow-auto`}
        >
          {chunk && (
            <div className="flex w-full flex-col gap-2 p-3">
              <p className="fond-bold text-text-alt-verba">
                Chunk {chunk.chunk_id}
              </p>
              <p className="text-sm text-text-alt-verba">{chunk.content}</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default VectorViewDeck;
